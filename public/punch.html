<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MyPunctoo ‚Äì Punch</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- JetBrains Mono for the punch card -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="css/style.css">
</head>
<body class="punch-body">
  <main class="punch-main">
<section class="punch-card" id="punch-card">
  <!-- Logo + product name -->
  <div class="punch-brand-row">
    <img src="assets/mypunctoo_logo.png" alt="MyPunctoo logo" class="punch-logo">
    <span class="punch-tag">Smart time tracking</span>
  </div>

  <!-- Context badge (IN / OUT) -->
  <div class="punch-mode" id="punch-mode">
    <!-- wordt via JS aangepast via setTitleAndSubtitle() -->
    <span class="punch-mode-dot"></span>
    <span class="punch-mode-label">Clock in</span>
  </div>

  <header class="punch-header">
    <h1 class="punch-title" id="punch-title">Clock in</h1>
    <p class="punch-subtitle" id="punch-subtitle">
      You scanned the IN-QR at your workplace.
    </p>
  </header>

  <div class="punch-status" id="punch-status">
    <!-- Filled by JavaScript -->
  </div>

  <!-- Plate verification (pattern check) -->
  <div class="punch-status" id="plate-verify" hidden>
    <p class="punch-text" id="plate-verify-text">Verifying plate‚Ä¶</p>
    <video id="plate-video" playsinline autoplay muted class="plate-video" hidden></video>
    <canvas id="plate-canvas" class="plate-canvas" hidden></canvas>
    <button type="button" class="punch-button" id="plate-capture" hidden>Capture plate</button>
    <button type="button" class="punch-button" id="plate-reset" hidden>Reset plate template</button>
  </div>

  <!-- First-time link form -->
  <form class="punch-form" id="punch-form" autocomplete="off" hidden>
    <label class="punch-label" for="employee-id">
      Enter your employee ID:
    </label>
    <input
      type="text"
      id="employee-id"
      class="punch-input"
      placeholder="e.g. EMP-001"
      required
    >

    <button type="submit" class="punch-button">
      Link this phone and punch
    </button>
  </form>

  <p class="punch-footnote" id="punch-footnote">
    This page only works via the QR code provided by your employer.
  </p>
</section>

  </main>

  <script>
    // ------------------------------
    // Config / constants
    // ------------------------------
    const DEVICE_USER_KEY = "mypunctoo_device_user";
    const SUBSCRIPTION_STATUS_KEY = "mypunctoo_subscription_status";
    const DEVICE_ID_KEY = "mypunctoo_device_id";
    const PLATE_TEMPLATE_PREFIX = "mypunctoo_plate_template_";
    const PLATE_THRESHOLD = 12; // Hamming distance threshold (lower = stricter)

    // ------------------------------
    // URL parameters: QR token + direction
    // ------------------------------
    function getPunchParams() {
      const params = new URLSearchParams(window.location.search);
      const qr = params.get("qr") || "demo-qr";
      const typeParam = (params.get("type") || "in").toLowerCase();
      const direction = typeParam === "out" ? "out" : "in"; // default: in
      return { qr, direction };
    }

    // ------------------------------
    // Subscription status (shared with portal)
    // ------------------------------
    function loadSubscriptionStatus() {
      try {
        const raw = window.localStorage.getItem(SUBSCRIPTION_STATUS_KEY);
        if (!raw) return "active";
        const parsed = JSON.parse(raw);
        return parsed === "inactive" ? "inactive" : "active";
      } catch (e) {
        console.warn("Could not read subscription status:", e);
        return "active";
      }
    }

    // ------------------------------
    // Device user storage (simulating a token)
    // ------------------------------
    function getStoredDeviceUser() {
      try {
        const raw = window.localStorage.getItem(DEVICE_USER_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (e) {
        console.warn("Could not read device user:", e);
        return null;
      }
    }

    function storeDeviceUser(user) {
      try {
        window.localStorage.setItem(DEVICE_USER_KEY, JSON.stringify(user));
      } catch (e) {
        console.warn("Could not store device user:", e);
      }
    }

    function getOrCreateDeviceId() {
      try {
        const existing = window.localStorage.getItem(DEVICE_ID_KEY);
        if (existing) return existing;
        const id = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : ("dev-" + Math.random().toString(16).slice(2) + Date.now());
        window.localStorage.setItem(DEVICE_ID_KEY, id);
        return id;
      } catch {
        return "";
      }
    }

    // ------------------------------
    // UI helpers
    // ------------------------------
    function formatTime(date) {
      return date.toLocaleTimeString("nl-BE", {
        hour: "2-digit",
        minute: "2-digit"
      });
    }

    function setTitleAndSubtitle(direction) {
      const titleEl = document.getElementById("punch-title");
      const subtitleEl = document.getElementById("punch-subtitle");

      if (direction === "in") {
        titleEl.textContent = "Clock in";
        subtitleEl.textContent = "You scanned the IN-QR at your workplace.";
      } else {
        titleEl.textContent = "Clock out";
        subtitleEl.textContent = "You scanned the OUT-QR at your workplace.";
      }
    }

    function showSubscriptionInactive() {
      const statusEl = document.getElementById("punch-status");
      const formEl = document.getElementById("punch-form");
      const titleEl = document.getElementById("punch-title");
      const subtitleEl = document.getElementById("punch-subtitle");

      titleEl.textContent = "Subscription inactive";
      subtitleEl.textContent = "Clocking is currently disabled for this company.";

      formEl.hidden = true;
      statusEl.innerHTML = `
        <p class="punch-emoji">‚õî</p>
        <p class="punch-text punch-text-main">
          Your employer's MyPunctoo subscription is <strong>inactive</strong>.
          Clocking is temporarily disabled.
        </p>
        <p class="punch-text">
          Please contact your manager or HR department if you think this is a mistake.
        </p>
      `;
    }

    function showFirstTimeForm() {
      const form = document.getElementById("punch-form");
      const status = document.getElementById("punch-status");

      form.hidden = false;
      status.innerHTML = `
        <p class="punch-text">
          This is the first time this phone is used with MyPunctoo.
        </p>
        <p class="punch-text">
          We link this device once to your <strong>employee ID</strong>.
          Next time you only need to scan the QR code.
        </p>
      `;
    }

    function showPunchResult(user, direction, qrToken) {
      const status = document.getElementById("punch-status");
      const now = new Date();
      const time = formatTime(now);

      const actionText = direction === "in" ? "clocked in" : "clocked out";
      const emoji = direction === "in" ? "üü¢" : "üîµ";

      status.innerHTML = `
        <p class="punch-emoji">${emoji}</p>
        <p class="punch-text punch-text-main">
          ${user.displayName}, you are <strong>${actionText}</strong> at <strong>${time}</strong>.
        </p>
        <p class="punch-text">
          QR reference: <code>${qrToken}</code>
        </p>
      `;
    }

    function showError(message) {
      const status = document.getElementById("punch-status");
      status.innerHTML = `
        <p class="punch-emoji">‚ö†Ô∏è</p>
        <p class="punch-text punch-text-main">${message}</p>
      `;
    }

    // ------------------------------
    // Plate (pattern) verification
    // NOTE: This is a "same plate" check (not photo-proof). It reduces misuse
    // by ensuring the same visual plate is presented, within a tolerance.
    // ------------------------------
    function templateKeyForQr(qr) {
      return `${PLATE_TEMPLATE_PREFIX}${qr}`;
    }

    function loadPlateTemplate(qr) {
      try {
        return window.localStorage.getItem(templateKeyForQr(qr));
      } catch {
        return null;
      }
    }

    function savePlateTemplate(qr, hashHex) {
      try {
        window.localStorage.setItem(templateKeyForQr(qr), hashHex);
      } catch {}
    }

    function resetPlateTemplate(qr) {
      try {
        window.localStorage.removeItem(templateKeyForQr(qr));
      } catch {}
    }

    function hexToBigInt(hex) {
      try {
        return BigInt('0x' + hex);
      } catch {
        return 0n;
      }
    }

    function hammingDistance64(aHex, bHex) {
      const a = hexToBigInt(aHex);
      const b = hexToBigInt(bHex);
      let x = a ^ b;
      let count = 0;
      while (x) {
        x &= (x - 1n);
        count++;
      }
      return count;
    }

    // pHash (64-bit) from a video frame
    // - draw to 32x32 grayscale
    // - compute DCT
    // - take top-left 8x8 (excluding [0][0])
    function computePHash64FromVideo(videoEl) {
      const size = 32;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      ctx.drawImage(videoEl, 0, 0, size, size);
      const img = ctx.getImageData(0, 0, size, size).data;

      // grayscale matrix
      const pixels = Array.from({ length: size }, () => new Array(size).fill(0));
      let idx = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const r = img[idx];
          const g = img[idx + 1];
          const b = img[idx + 2];
          idx += 4;
          pixels[y][x] = 0.299 * r + 0.587 * g + 0.114 * b;
        }
      }

      // 2D DCT
      const dct = Array.from({ length: size }, () => new Array(size).fill(0));
      const c = (u) => (u === 0 ? 1 / Math.sqrt(2) : 1);

      for (let u = 0; u < size; u++) {
        for (let v = 0; v < size; v++) {
          let sum = 0;
          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              sum +=
                pixels[y][x] *
                Math.cos(((2 * x + 1) * v * Math.PI) / (2 * size)) *
                Math.cos(((2 * y + 1) * u * Math.PI) / (2 * size));
            }
          }
          dct[u][v] = (2 / size) * c(u) * c(v) * sum;
        }
      }

      // collect 8x8 low frequencies
      const vals = [];
      for (let u = 0; u < 8; u++) {
        for (let v = 0; v < 8; v++) {
          if (u === 0 && v === 0) continue;
          vals.push(dct[u][v]);
        }
      }

      // median
      const sorted = [...vals].sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)] || 0;

      // build 64-bit hash
      let hash = 0n;
      let bit = 0;
      for (let u = 0; u < 8; u++) {
        for (let v = 0; v < 8; v++) {
          const val = dct[u][v];
          const isOne = val > median;
          if (isOne) {
            hash |= (1n << BigInt(63 - bit));
          }
          bit++;
        }
      }

      // return hex padded to 16 chars
      let hex = hash.toString(16);
      hex = hex.padStart(16, '0');
      return hex;
    }

    async function openCamera(videoEl) {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      videoEl.srcObject = stream;
      await new Promise((resolve) => {
        videoEl.onloadedmetadata = () => resolve();
      });
      return stream;
    }

    function stopCamera(stream) {
      if (!stream) return;
      for (const t of stream.getTracks()) t.stop();
    }

    async function verifyPlatePattern(qr) {
      const verifyWrap = document.getElementById('plate-verify');
      const verifyText = document.getElementById('plate-verify-text');
      const videoEl = document.getElementById('plate-video');
      const captureBtn = document.getElementById('plate-capture');
      const resetBtn = document.getElementById('plate-reset');

      verifyWrap.hidden = false;
      videoEl.hidden = false;

      let stream = null;
      try {
        stream = await openCamera(videoEl);
      } catch (e) {
        verifyText.textContent = 'Camera access is required to verify the plate pattern.';
        captureBtn.hidden = true;
        resetBtn.hidden = true;
        return { ok: false, reason: 'camera_denied' };
      }

      const existingTemplate = loadPlateTemplate(qr);
      resetBtn.hidden = false;
      resetBtn.onclick = () => {
        resetPlateTemplate(qr);
        window.location.reload();
      };

      if (!existingTemplate) {
        verifyText.textContent = 'First time on this phone: hold the plate in view and press Capture.';
        captureBtn.hidden = false;

        const hash = await new Promise((resolve) => {
          captureBtn.onclick = () => {
            try {
              const h = computePHash64FromVideo(videoEl);
              resolve(h);
            } catch (e) {
              resolve(null);
            }
          };
        });

        stopCamera(stream);
        if (!hash) return { ok: false, reason: 'capture_failed' };

        savePlateTemplate(qr, hash);
        return { ok: true, distance: 0, templated: true };
      }

      // Existing template: auto-capture a few frames and take best distance
      verifyText.textContent = 'Verifying plate‚Ä¶ keep the plate steady for a moment.';
      captureBtn.hidden = true;

      let best = { dist: 999, hash: null };
      for (let i = 0; i < 3; i++) {
        await new Promise(r => setTimeout(r, 350));
        try {
          const h = computePHash64FromVideo(videoEl);
          const d = hammingDistance64(existingTemplate, h);
          if (d < best.dist) best = { dist: d, hash: h };
        } catch {}
      }

      stopCamera(stream);

      const ok = best.dist <= PLATE_THRESHOLD;
      return { ok, distance: best.dist, threshold: PLATE_THRESHOLD };
    }

    // ------------------------------
    // Real punch to backend
    // ------------------------------
    async function sendPunchToServer(user, direction, qrToken) {
      const deviceId = getOrCreateDeviceId();

      const resp = await fetch('/api/punch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          qr: qrToken,
          direction,
          employeeToken: user.id,
          deviceId,
          patternOk: true
        })
      });

      const data = await resp.json().catch(() => ({}));
      if (!resp.ok || !data.ok) {
        const msg = data && data.error ? data.error : 'Punch failed.';
        throw new Error(msg);
      }
      return data;
    }

    // ------------------------------
    // Init
    // ------------------------------
    (function initPunchPage() {
      const { qr, direction } = getPunchParams();
      const subscriptionStatus = loadSubscriptionStatus();
      const form = document.getElementById("punch-form");
      const footnote = document.getElementById("punch-footnote");

      setTitleAndSubtitle(direction);

      // If subscription is inactive: no punch allowed
      if (subscriptionStatus === "inactive") {
        showSubscriptionInactive();
        footnote.textContent = "Subscription is inactive. Clocking is currently disabled for this company.";
        return;
      }

      const storedUser = getStoredDeviceUser();

      if (storedUser) {
        // Device already linked ‚Üí verify plate pattern, then punch
        form.hidden = true;
        (async () => {
          const verify = await verifyPlatePattern(qr);
          if (!verify.ok) {
            showError(`Plate mismatch. Please scan the correct plate. (score: ${verify.distance ?? 'n/a'})`);
            return;
          }
          try {
            await sendPunchToServer(storedUser, direction, qr);
            showPunchResult(storedUser, direction, qr);
          } catch (e) {
            showError(e.message || 'Punch failed.');
          }
        })();
      } else {
        // First time on this device
        showFirstTimeForm();
      }

      form.addEventListener("submit", function (event) {
        event.preventDefault();

        const input = document.getElementById("employee-id");
        const value = input.value.trim();
        if (!value) return;

        const newUser = {
          id: value,
          displayName: value
        };

        storeDeviceUser(newUser);
        form.hidden = true;
        (async () => {
          const verify = await verifyPlatePattern(qr);
          if (!verify.ok) {
            showError(`Plate mismatch. Please scan the correct plate. (score: ${verify.distance ?? 'n/a'})`);
            return;
          }
          try {
            await sendPunchToServer(newUser, direction, qr);
            showPunchResult(newUser, direction, qr);
          } catch (e) {
            showError(e.message || 'Punch failed.');
          }
        })();
      });
    })();
  </script>
</body>
</html>

